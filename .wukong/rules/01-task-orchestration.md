# Task Orchestration Protocol (任务编排协议)

## Pre-Delegation Declaration (召唤分身前声明)

**BEFORE EVERY Avatar summoning, declare:**

```
我将召唤分身:
- **六根**: [眼/耳/鼻/舌/身/意/超越六根]
- **Avatar**: [眼分身/耳分身/鼻分身/舌分身/斗战胜佛/意分身/内观悟空]
- **Reason**: [为什么需要这个分身]
- **Expected Outcome**: [期望的交付物]
- **Background**: [true/false - 是否后台运行]
```

**本体职责提醒**:
- 本体专注于用户交互，不直接写大量代码
- 代码实现交给斗战胜佛 (身)
- 本体负责监督、验证、汇报

## Avatar Selection Decision Tree (六根选择决策树)

```
1. 是代码探索/信息搜索/研究任务?
   ✓ YES → 👁️ 眼分身 (观) - background=true
   ✗ NO → Continue

2. 是需求分析/澄清/理解用户意图任务?
   ✓ YES → 👂 耳分身 (听)
   ✗ NO → Continue

3. 是代码审查/质量检查/安全扫描任务?
   ✓ YES → 👃 鼻分身 (觉) - background=true
   ✗ NO → Continue

4. 是测试编写/文档生成/报告输出任务?
   ✓ YES → 👅 舌分身 (言)
   ✗ NO → Continue

5. 是代码实现/编写/开发/修复任务?
   ✓ YES → ⚔️ 斗战胜佛 (行)
   ✗ NO → Continue

6. 是架构/设计/技术选型/决策任务?
   ✓ YES → 🧠 意分身 (思)
   ✗ NO → Continue

7. 是流程反思/锚点维护/上下文管理任务?
   ✓ YES → 🔮 内观悟空 (超越六根)
   ✗ NO → Continue

8. 是用户对话/问答/简单任务?
   ✓ YES → 本体直接处理
```

**六根快速对照表:**

| 六根 | 分身 | 能力维度 | Background? |
|------|------|----------|-------------|
| 眼 | 眼分身 | 观察·探索·搜索 | Yes |
| 耳 | 耳分身 | 倾听·理解·需求 | No |
| 鼻 | 鼻分身 | 感知·审查·检测 | Yes |
| 舌 | 舌分身 | 表达·沟通·文档 | No |
| 身 | 斗战胜佛 | 执行·实现·行动 | No |
| 意 | 意分身 | 思考·设计·决策 | No |
| - | 内观悟空 | 反思·锚点·健康 | No |

## Introspection Protocol (内观协议)

> 吾日三省吾身 - 复杂任务完成后，进行深度反思。
> 基于 feiskyer/claude-code-settings 的 reflection-harder 框架增强。
> **与如意金箍棒协议集成** - 内观时同步维护锚点和上下文健康度。

### 何时召唤内观悟空

| 触发条件 | 内观深度 | 说明 |
|----------|----------|------|
| 复杂任务完成 | 深度 | 多分身协作的任务 |
| 任务失败/重做 | 深度 | 分析失败原因 |
| 用户主动请求 | 按需 | "反思一下"、"总结经验"、"内观" |
| 简单任务完成 | 跳过 | 不需要内观 |
| 发现重要模式 | 标准 | 值得沉淀的经验 |
| **上下文 > 75%** | **标准** | **存档前反思，提取锚点** |
| **会话即将结束** | **快速** | **确保跨会话传递就绪** |

### 内观深度

```
快速内观 (1-2 分钟):
├── 主要问题识别
├── 1-2 条改进建议
└── 适用: 简单任务

标准内观 (3-5 分钟):
├── 3-4 维度分析
├── 结构化报告
├── 模式提炼
└── 适用: 常规任务

深度内观 (5-10 分钟):
├── 全 6 维度分析
│   ├── 问题与解决
│   ├── 代码模式与架构
│   ├── 用户偏好与工作流
│   ├── 系统理解
│   ├── 知识缺口与改进
│   └── 🆕 上下文与锚点健康度
├── 完整反思报告
├── 更新 notepads/learnings.md
├── 生成行动项
├── 🆕 提取并创建锚点 [D]/[C]/[I]/[P]/[U]
├── 🆕 验证现有锚点有效性
├── 🆕 生成三态摘要 (缩/常/巨)
└── 适用: 复杂任务/失败分析
```

### 内观输出要求

```
1. 会话概览
   - 目标、结果、持续时间

2. 问题解决记录
   - 用户影响 → 技术原因 → 解决方案 → 学习

3. 建立的模式
   - 可复用模式提炼，带示例和适用场景

4. 用户偏好
   - 带证据引用的偏好记录

5. 改进机会
   - 立即可行 vs 未来优化

6. 行动项
   - 具体、可执行的后续步骤
```

### 内观原则

```
✅ 正确的内观:
├── 提炼可复用模式
├── 记录用户工作风格
├── 累积知识让后续更高效
├── 识别工作流优化机会
├── 明确自主边界
└── 将学习沉淀到 notepads/

❌ 错误的内观:
├── 只批评不肯定
├── 泛泛而谈无法执行
├── 为了反思而反思
├── 忽视成功经验
└── 不产出可复用知识
```

### 内观后的知识沉淀

```
内观完成后，必须更新知识库:
├── notepads/{plan}/learnings.md  ← 经验教训
├── notepads/{plan}/decisions.md  ← 重要决策
├── notepads/{plan}/issues.md     ← 问题记录
└── notepads/{plan}/breakthroughs.md ← 突破记录 (如有)
```

### 内观与金箍棒协议集成

```
内观完成后，必须维护上下文系统:

1. 锚点提取
   ├── 扫描本次会话的关键信息
   ├── 创建新锚点 → 追加到 context/anchors.md
   └── 类型: [D]决策 [C]约束 [I]接口 [P]问题 [U]偏好

2. 锚点验证
   ├── 检查 anchors.md 中的现有锚点
   ├── 标记过期锚点 ❌
   ├── 更新需修改的锚点 ⚠️
   └── 确认有效锚点 ✅

3. 三态存档
   ├── context/current/compact.md  ← 🔸 缩形态摘要
   ├── context/current/normal.md   ← 🔹 常形态摘要
   └── context/current/expanded.md ← 🔶 完整内观报告

4. 上下文健康评估
   ├── 锚点覆盖度: 关键信息是否都有锚点
   ├── 信息密度: 是否有可压缩的冗余
   └── 跨会话就绪: 是否可以安全结束会话
```

### 内观触发的存档流程

```
当内观检测到以下情况时，触发存档:

上下文 > 75%:
├── 1. 生成三态摘要
├── 2. 将 current/ 移动到 sessions/{date}-{name}/
├── 3. 创建新的 current/ 使用 compact.md
└── 4. 通知用户: "上下文已存档，可安全继续"

会话即将结束:
├── 1. 快速内观
├── 2. 确保关键锚点已提取
├── 3. 生成 compact.md 供下次使用
└── 4. 提示: "下次可以说'继续{任务}'加载上下文"
```

## Task Prompt Template

```markdown
## 任务 (TASK)
[具体、可衡量的目标]

## 背景 (CONTEXT)
- 技术栈: [C++/Python/FastAPI/...]
- 相关文件: [file paths]
- 现有模式: [patterns to follow]

## 期望产出 (EXPECTED OUTCOME)
- [ ] [具体交付物 1]
- [ ] [具体交付物 2]
- [ ] [成功标准]

## 必须做 (MUST DO)
- [遵循的规范]
- [参考的文件/模块]
- [性能要求]

## 禁止做 (MUST NOT DO)
- [禁止的反模式]
- [避免的技术债]
```

## 接口契约文档 (Interface Contract)

> **并行实现前，必须先定义接口契约，避免集成时的接口不匹配问题。**

### 何时需要接口契约

| 场景 | 是否需要 | 原因 |
|------|----------|------|
| 多个模块并行实现 | ✅ 必须 | 确保接口一致 |
| 单模块实现 | ❌ 不需要 | 无并行集成风险 |
| 已有参考实现 | ⚠️ 可选 | 可从参考代码推断 |

### 契约文档位置

```
.wukong/notepads/{plan}/interfaces.md
```

### 契约文档格式

```markdown
# 接口契约: {Project Name}

## 模块依赖图
```
A ──→ C
B ──→ C
```

## 模块接口定义

### ModuleA (credentials.py)

```python
class Credentials:
    @staticmethod
    def get_git_token() -> Optional[str]:
        """获取 Git Token，返回 None 表示未配置"""
        ...

    @staticmethod
    def get_ollama_config() -> dict:
        """返回 {"url": str, "model": str, "timeout": int}"""
        ...
```

### ModuleB (sanitizer.py)

```python
class Sanitizer:
    @classmethod
    def sanitize(cls, data: Any) -> Any:
        """递归脱敏，移除敏感字段"""
        ...
```

## 错误处理约定

| 模块 | 错误处理方式 |
|------|-------------|
| credentials | 返回 None 或 默认值 |
| tools | 返回 {"error": str} |
| agent | 抛出 RuntimeError |
| server | 抛出 HTTPException |

## 数据流

```
用户请求 → Server → Agent → Tools → 返回脱敏结果
```
```

### 契约生成时机

```
设计阶段 (架构悟空):
├── 1. 确定模块划分
├── 2. 定义模块接口
├── 3. 生成 interfaces.md
└── 4. 分发给各斗战胜佛

实现阶段 (斗战胜佛):
├── 1. 阅读 interfaces.md
├── 2. 严格按接口实现
└── 3. 不得擅自修改接口
```

## Parallel Execution Strategy (筋斗云并行策略)

> **筋斗云**: 一个筋斗十万八千里。分身术的精髓在于**同时出击**，而非排队等候。

### The Parallelization Decision Tree (并行决策树)

```
开始任务分析
     │
     ▼
┌─────────────────────────────────────────┐
│ Q1: 任务可以分解为多个独立子任务吗？        │
└─────────────────────────────────────────┘
     │
     ├── NO → 单分身串行执行
     │
     ▼ YES
┌─────────────────────────────────────────┐
│ Q2: 子任务之间有数据依赖吗？               │
│     (一个的输出是另一个的输入)              │
└─────────────────────────────────────────┘
     │
     ├── YES → 按依赖顺序串行
     │
     ▼ NO
┌─────────────────────────────────────────┐
│ Q3: 子任务会修改同一个文件吗？             │
└─────────────────────────────────────────┘
     │
     ├── YES → 串行执行（避免冲突）
     │
     ▼ NO
┌─────────────────────────────────────────┐
│ ✅ 可以并行！召唤多个分身同时执行          │
└─────────────────────────────────────────┘
```

### Parallelization Patterns (并行模式)

#### Pattern 1: **分身群攻** (Multi-Module Implementation)
**场景**: 实现多个独立模块（无相互依赖）
**加速比**: 理论 Nx（N = 模块数）

```
设计完成后:
     │
     ├──→ [斗战胜佛 A] 实现 module_a.py  ──┐
     ├──→ [斗战胜佛 B] 实现 module_b.py  ──┼──→ 合并验证
     └──→ [斗战胜佛 C] 实现 module_c.py  ──┘

# 召唤方式 (在同一条消息中发送多个 Task)
Task(subagent_type="general-purpose", prompt="实现 module_a", run_in_background=true)
Task(subagent_type="general-purpose", prompt="实现 module_b", run_in_background=true)
Task(subagent_type="general-purpose", prompt="实现 module_c", run_in_background=true)
```

#### Pattern 2: **侦察兵 + 主力军** (Scout & Infantry)
**场景**: 实现功能时需要不断查阅参考
**加速比**: 减少等待时间

```
开始实现:
     │
     ├──→ [眼分身] 研究相关 API 和模式 (后台)
     │         │
     │         └──→ 持续提供参考信息
     │
     └──→ [斗战胜佛] 开始实现代码
               │
               └──→ 遇到不确定时，从眼分身获取答案

# 召唤方式
Task(subagent_type="Explore", prompt="研究 X 库的用法和最佳实践", run_in_background=true)
Task(subagent_type="general-purpose", prompt="实现 Y 功能，参考眼分身的发现")
```

#### Pattern 3: **TDD 钳形攻势** (Test + Implement Pincer)
**场景**: 接口已明确定义（设计文档/头文件）
**加速比**: ~2x

```
接口定义完成:
     │
     ├──→ [舌分身] 根据接口编写测试 (后台)
     │
     └──→ [斗战胜佛] 实现接口 (后台)
               │
               ▼
          [合并] → 运行测试 → 验证

# 召唤方式
Task(subagent_type="general-purpose", prompt="根据接口定义编写测试", run_in_background=true)
Task(subagent_type="general-purpose", prompt="实现接口", run_in_background=true)
# 等待两者完成后运行测试
```

#### Pattern 4: **代码 + 配置并行** (Code + Config Parallel)
**场景**: 实现代码的同时准备部署配置
**加速比**: ~1.5x

```
设计完成后:
     │
     ├──→ [斗战胜佛] 实现核心代码
     │
     └──→ [意分身] 准备 Dockerfile / CI 配置 (后台)
               │
               └──→ 容器配置不依赖具体实现细节

# 召唤方式
Task(subagent_type="general-purpose", prompt="实现核心功能代码")
Task(subagent_type="general-purpose", prompt="准备 Dockerfile 和 docker-compose", run_in_background=true)
```

#### Pattern 5: **蜂群模式** (Swarm - Mass Operations)
**场景**: 批量重构/迁移多个独立文件
**加速比**: ~Nx

```
重构计划确定后:
     │
     ├──→ [斗战胜佛 A] 重构 file_1.py  ──┐
     ├──→ [斗战胜佛 B] 重构 file_2.py  ──┤
     ├──→ [斗战胜佛 C] 重构 file_3.py  ──┼──→ 合并
     └──→ [斗战胜佛 D] 重构 file_4.py  ──┘

# 召唤方式 (限制同时 3-4 个分身)
Task(subagent_type="general-purpose", prompt="重构 file_1", run_in_background=true)
Task(subagent_type="general-purpose", prompt="重构 file_2", run_in_background=true)
Task(subagent_type="general-purpose", prompt="重构 file_3", run_in_background=true)
```

### Parallelization Rules (并行规则)

#### ✅ 可以并行的场景

| 场景 | 模式 | 最大并行数 |
|------|------|-----------|
| 实现多个独立模块 | 分身群攻 | 3-4 |
| 实现 + 探索参考 | 侦察兵+主力军 | 2 |
| 实现 + 写测试 (接口已定) | TDD钳形攻势 | 2 |
| 代码 + 部署配置 | 代码+配置并行 | 2 |
| 批量文件修改 | 蜂群模式 | 3-4 |
| 多文件代码审查 | 审查分身群 | 3-4 |
| 多模块代码探索 | 探索分身群 | 3-4 |

#### ❌ 必须串行的场景

| 场景 | 原因 |
|------|------|
| 需求 → 架构 → 实现 | 依赖上游输出 |
| 修改同一文件的多个任务 | 会产生冲突 |
| 测试依赖未完成的代码 | 会失败 |
| 需要用户确认的决策点 | 阻塞等待 |

### Parallel Execution Syntax (并行召唤语法)

**关键**: 在**同一条消息**中发送多个 Task 调用

```python
# ✅ 正确: 同一消息中多个 Task (并行执行)
<message>
Task(subagent_type="general-purpose", prompt="任务A", run_in_background=true)
Task(subagent_type="general-purpose", prompt="任务B", run_in_background=true)
Task(subagent_type="general-purpose", prompt="任务C", run_in_background=true)
</message>

# ❌ 错误: 分开发送 (串行执行)
<message>Task(...任务A...)</message>
<message>Task(...任务B...)</message>
<message>Task(...任务C...)</message>
```

### Resource Management (资源管理)

```
并行分身限制:
├── 最大同时运行: 3-4 个分身
├── 后台探索: 不计入限制
└── 超过限制时: 批次执行

示例 (8个独立模块):
├── 第一批: 模块 1, 2, 3, 4 (并行)
├── 等待完成
└── 第二批: 模块 5, 6, 7, 8 (并行)
```

---

### File Territory Protocol (文件领地协议)

> **并行实现时最容易撞车：两个分身改同一个文件** - 用领地协议避免冲突。

#### 领地声明规则

```
┌─────────────────────────────────────────────────────────────────┐
│  1️⃣ 实现前声明领地                                              │
│     斗战胜佛开始实现前，必须声明改动领地:                         │
│                                                                   │
│     ```                                                           │
│     ## 领地声明                                                   │
│     分身: 斗战胜佛 A                                              │
│     领地:                                                         │
│     - src/auth/login.py (全文件)                                 │
│     - src/auth/utils.py (函数: validate_token)                   │
│     - tests/test_auth.py (新增)                                  │
│     ```                                                           │
├─────────────────────────────────────────────────────────────────┤
│  2️⃣ 领地互斥                                                    │
│     其他分身不得在同一领地写实现性内容                            │
│     ✅ 允许: 读取、评论、建议                                     │
│     ❌ 禁止: 编辑、写入、修改                                     │
├─────────────────────────────────────────────────────────────────┤
│  3️⃣ 冲突处理                                                    │
│     若必须重叠 (两个分身需要改同一文件):                          │
│     - 由本体重新分区 (拆分成不重叠的部分)                         │
│     - 或串行化 (先完成一个，再开始另一个)                         │
└─────────────────────────────────────────────────────────────────┘
```

#### 领地类型

| 类型 | 格式 | 说明 |
|------|------|------|
| 全文件 | `src/module.py` | 独占整个文件 |
| 函数级 | `src/module.py:func_name` | 只改特定函数 |
| 类级 | `src/module.py:ClassName` | 只改特定类 |
| 新增 | `src/new_file.py (新增)` | 创建新文件 |

#### 领地冲突检测

```
本体在分发任务前，检查领地冲突:

任务分发:
├── 斗战胜佛 A: src/auth.py, src/utils.py
├── 斗战胜佛 B: src/api.py, src/utils.py  ← ⚠️ 冲突!
│                          ↑
│                    与 A 的 utils.py 重叠
│
└── 冲突解决:
    ├── 方案1: 重新分区
    │   - A: src/auth.py, src/utils.py:validate_*
    │   - B: src/api.py, src/utils.py:format_*
    │
    └── 方案2: 串行化
        - A 先完成 → B 再开始
```

#### 领地释放

```
分身完成任务后，自动释放领地:

斗战胜佛 A 完成:
├── 输出实现报告
├── 标记: 领地已释放
└── 其他分身可接管
```

### Merge Protocol (合并协议)

并行任务完成后:

```
1. 收集所有分身的输出
2. 检查是否有冲突
3. 如有冲突 → 手动解决
4. 运行完整验证 (构建 + 测试)
5. 确认无误后继续
```

## Domain-Specific Patterns

### C++ Projects

```markdown
## Build & Test Commands
- Configure: cmake -B build -DCMAKE_BUILD_TYPE=Release
- Build: cmake --build build -j$(nproc)
- Test: ctest --test-dir build --output-on-failure
- Coverage: gcov/lcov

## Code Patterns
- RAII for resource management
- Smart pointers (unique_ptr, shared_ptr)
- Exception safety guarantees
- const correctness
```

### Python Projects

```markdown
## Build & Test Commands
- Install: pip install -e ".[dev]"
- Test: pytest -v --cov
- Lint: ruff check . && mypy .
- Format: ruff format .

## Code Patterns
- Type hints (Python 3.10+)
- Pydantic for data validation
- async/await for I/O
- Dependency injection
```

### FastAPI Projects

```markdown
## Structure
src/
├── api/           # Route handlers
├── core/          # Config, security
├── models/        # Pydantic models
├── services/      # Business logic
└── repositories/  # Data access

## Patterns
- Dependency injection via Depends
- Async database operations
- Response models for validation
- OpenAPI documentation
```

### Video Processing

```markdown
## Libraries
- FFmpeg: transcoding, muxing
- GStreamer: pipeline processing
- OpenCV: frame analysis
- VAAPI/NVENC: hardware acceleration

## Patterns
- Zero-copy frame passing
- Pipeline parallelism
- Memory pool management
- Frame rate control
```

### AI Inference

```markdown
## Runtimes
- ONNX Runtime: cross-platform
- TensorRT: NVIDIA optimization
- OpenVINO: Intel optimization

## Patterns
- Batching for throughput
- Async inference
- Model versioning
- Input validation
```

## Workflow Tracks - Default DAG (轨道默认依赖图)

> **并行要"可预测"** - 每条轨道固定成默认 DAG，避免"大家一起干但互相打架"。

---

### Track A: Feature Development (功能开发)

**Trigger**: "Add", "Create", "New", "Implement feature"

**Default DAG**:
```
┌─────────────────────────────────────────────────────────────────┐
│  Phase 1: 需求+探索 (并行)                                        │
│  ┌─────────┐    ┌─────────┐                                      │
│  │ 👂 耳    │    │ 👁 眼    │  ← 可并行，无依赖                    │
│  │ 需求澄清  │    │ 现状探索  │                                      │
│  └────┬────┘    └────┬────┘                                      │
│       │              │                                            │
│       └──────┬───────┘                                            │
│              ▼                                                    │
├─────────────────────────────────────────────────────────────────┤
│  Phase 2: 设计 (串行)                                             │
│              ┌─────────┐                                          │
│              │ 🧠 意    │  ← 依赖 Phase 1 的输出                   │
│              │ 架构设计  │                                          │
│              └────┬────┘                                          │
│                   ▼                                               │
├─────────────────────────────────────────────────────────────────┤
│  Phase 3: 实现 (串行)                                             │
│              ┌─────────┐                                          │
│              │ ⚔️ 身    │  ← 依赖设计方案                          │
│              │ 代码实现  │                                          │
│              └────┬────┘                                          │
│                   ▼                                               │
├─────────────────────────────────────────────────────────────────┤
│  Phase 4: 验证+审查 (并行)                                        │
│  ┌─────────┐    ┌─────────┐                                      │
│  │ 👅 舌    │    │ 👃 鼻    │  ← 可并行，无依赖                    │
│  │ 测试编写  │    │ 代码审查  │                                      │
│  └────┬────┘    └────┬────┘                                      │
│       │              │                                            │
│       └──────┬───────┘                                            │
│              ▼                                                    │
├─────────────────────────────────────────────────────────────────┤
│  Phase 5: 收敛 (本体)                                             │
│              ┌─────────┐                                          │
│              │ 🐵 本体  │  ← 汇总、验证、交付报告                   │
│              │ Gate验证 │                                          │
│              └─────────┘                                          │
└─────────────────────────────────────────────────────────────────┘
```

**Gate 要求**: L2 + AC 测试覆盖（核心流程建议 L3）

---

## 八识验证流水线 (Eight Consciousness Verification Pipeline)

> **六根执行 → 末那过滤 → 戒定慧验证 → 阿赖耶沉淀**
> 所有轨道在 Phase 5 收敛前，必须经过此流水线。

### 流水线架构

```
六根分身输出 (眼/耳/鼻/舌/身/意)
          │
          ▼
┌─────────────────────────────────────────┐
│      末那识 (Manas Filter)               │
│  ┌───────────────────────────────────┐  │
│  │ 检查隐藏假设:                       │  │
│  │ □ 是否假设了用户未说的条件？         │  │
│  │ □ 是否假设了代码行为？(需验证)       │  │
│  │ □ 是否有未验证的性能假设？           │  │
│  │ □ 是否有潜在偏见？                   │  │
│  └───────────────────────────────────┘  │
│  输出: 假设清单 + 偏见标记               │
└────────────────┬────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────┐
│           戒 关 (Sila Gate)              │
│  ┌───────────────────────────────────┐  │
│  │ 规则遵守检查:                       │  │
│  │ □ Output Contract 是否完整？        │  │
│  │ □ Do/Don't 边界是否遵守？           │  │
│  │ □ 领地协议是否遵守？                 │  │
│  │ □ 安全规范是否满足？                 │  │
│  └───────────────────────────────────┘  │
│  通过 → 继续 | 违反 → 返回六根修正       │
└────────────────┬────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────┐
│           定 关 (Samadhi Gate)           │
│  ┌───────────────────────────────────┐  │
│  │ 可复现/可运行检查:                   │  │
│  │ □ 是否有可执行的验证命令？           │  │
│  │ □ 本地是否可以复现？                 │  │
│  │ □ 测试是否通过？                     │  │
│  │ □ 构建是否成功？                     │  │
│  └───────────────────────────────────┘  │
│  达到 L2 → 继续 | 未达到 → 补充验证      │
└────────────────┬────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────┐
│           慧 关 (Prajna Gate)            │
│  ┌───────────────────────────────────┐  │
│  │ 验证 & 抽象检查:                     │  │
│  │ □ AC 是否全部满足？                  │  │
│  │ □ 是否有可提炼的模式？               │  │
│  │ □ 是否需要创建 ADR 锚点？            │  │
│  │ □ 是否有值得记录的经验？             │  │
│  └───────────────────────────────────┘  │
│  达到 L3 → 继续 | L2 足够 → 标记通过     │
└────────────────┬────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────┐
│        阿赖耶识 (Alaya Store)            │
│  ┌───────────────────────────────────┐  │
│  │ 业力沉淀:                           │  │
│  │                                     │  │
│  │ 正业 (善种子):                       │  │
│  │   - 成功经验 → notepads/learnings   │  │
│  │   - 决策锚点 → context/anchors      │  │
│  │   - 可复用模式 → skills/            │  │
│  │                                     │  │
│  │ 恶业 (待偿债):                       │  │
│  │   - 技术债 → issues.md              │  │
│  │   - 已知风险 → risk-hotspots        │  │
│  │   - 临时方案 → tech-debt-tracker    │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

### 流水线触发时机

| 轨道 | 触发位置 | 验证深度 |
|------|----------|----------|
| Feature (Track A) | Phase 4→5 之间 | 完整流水线 |
| Fix (Track B) | Phase 3→4 之间 | 戒+定关为主 |
| Refactor (Track C) | Phase 4→5 之间 | 重点检查行为不变 |
| Direct (Track D) | 分身返回后 | 轻量级检查 |

### 流水线失败处理

```
验证失败时:
├── 末那识标记假设 → 返回六根，要求验证假设
├── 戒关违反 → 返回六根，修正输出格式/边界
├── 定关失败 → 返回身分身，补充验证命令
└── 慧关未达标 → 本体决定是否接受 L2 降级
```

---

### Track B: Bug Fix (问题修复)

**Trigger**: "Fix", "Bug", "Error", "Crash", "Issue"

**Default DAG**:
```
┌─────────────────────────────────────────────────────────────────┐
│  Phase 1: 定位+审查 (并行)                                        │
│  ┌─────────┐    ┌─────────┐                                      │
│  │ 👁 眼    │    │ 👃 鼻    │  ← 可并行：探索现状 + 审查问题代码     │
│  │ 问题定位  │    │ 根因分析  │                                      │
│  └────┬────┘    └────┬────┘                                      │
│       │              │                                            │
│       └──────┬───────┘                                            │
│              ▼                                                    │
├─────────────────────────────────────────────────────────────────┤
│  Phase 2: 修复 (串行)                                             │
│              ┌─────────┐                                          │
│              │ ⚔️ 身    │  ← 依赖定位结果，无需完整设计             │
│              │ 代码修复  │                                          │
│              └────┬────┘                                          │
│                   ▼                                               │
├─────────────────────────────────────────────────────────────────┤
│  Phase 3: 回归测试 (串行)                                         │
│              ┌─────────┐                                          │
│              │ 👅 舌    │  ← 添加复现用例 + 回归测试                │
│              │ 测试验证  │                                          │
│              └────┬────┘                                          │
│                   ▼                                               │
├─────────────────────────────────────────────────────────────────┤
│  Phase 4: 复盘 (可选)                                             │
│              ┌─────────┐                                          │
│              │ 🔮 内观  │  ← 复杂 bug 建议复盘，提取经验            │
│              │ 经验沉淀  │                                          │
│              └─────────┘                                          │
└─────────────────────────────────────────────────────────────────┘
```

**Gate 要求**: L2 + 复现用例 + 回归测试通过

---

### Track C: Refactoring (代码重构)

**Trigger**: "Refactor", "Clean", "Modernize", "Optimize"

**Default DAG**:
```
┌─────────────────────────────────────────────────────────────────┐
│  Phase 1: 现状分析 (串行)                                         │
│              ┌─────────┐                                          │
│              │ 👁 眼    │  ← 分析现状、耦合关系、依赖图             │
│              │ 现状&耦合 │                                          │
│              └────┬────┘                                          │
│                   ▼                                               │
├─────────────────────────────────────────────────────────────────┤
│  Phase 2: 重构策略 (串行)                                         │
│              ┌─────────┐                                          │
│              │ 🧠 意    │  ← 制定重构策略（不是完整架构设计）        │
│              │ 重构策略  │                                          │
│              └────┬────┘                                          │
│                   ▼                                               │
├─────────────────────────────────────────────────────────────────┤
│  Phase 3: 实施 (串行)                                             │
│              ┌─────────┐                                          │
│              │ ⚔️ 身    │  ← 按策略实施，保持行为不变               │
│              │ 代码重构  │                                          │
│              └────┬────┘                                          │
│                   ▼                                               │
├─────────────────────────────────────────────────────────────────┤
│  Phase 4: 验证 (并行)                                             │
│  ┌─────────┐    ┌─────────┐                                      │
│  │ 👃 鼻    │    │ 👅 舌    │  ← 可并行：可维护性审查 + 回归测试    │
│  │ 可维护性  │    │ 回归测试  │                                      │
│  └────┬────┘    └────┬────┘                                      │
│       │              │                                            │
│       └──────┬───────┘                                            │
│              ▼                                                    │
├─────────────────────────────────────────────────────────────────┤
│  Phase 5: Gate                                                    │
│              ┌─────────┐                                          │
│              │ 🐵 本体  │  ← 验证行为不变 + 质量提升                │
│              │ 行为对齐  │                                          │
│              └─────────┘                                          │
└─────────────────────────────────────────────────────────────────┘
```

**Gate 要求**: L2 + 行为不变证明（前后输出一致）

---

### Track D: Direct (直接执行)

**Trigger**: 简单命令、用户显式召唤 (@语法)

**Default DAG**:
```
┌─────────────────────────────────────────────────────────────────┐
│  用户显式召唤分身 → 分身执行 → 仍必须走验证 Gate                   │
│                                                                   │
│  @眼 探索X → 👁 眼分身 → 返回探索报告                              │
│  @意 设计X → 🧠 意分身 → 返回设计文档                              │
│  @身 实现X → ⚔️ 斗战胜佛 → 返回实现报告 → Gate 验证               │
│                                                                   │
│  注意: 即使直接召唤，实现类任务仍必须通过 L1+ 验证                  │
└─────────────────────────────────────────────────────────────────┘
```

**Gate 要求**: L1（简单任务可降级，但仍需证据）

---

### DAG 选择决策树

```
用户请求
    │
    ▼
┌─────────────────────────────────┐
│ 是否使用 @ 显式召唤分身？         │
└─────────────────────────────────┘
    │
    ├── YES → Track D (Direct)
    │
    ▼ NO
┌─────────────────────────────────┐
│ 关键词识别                        │
├─────────────────────────────────┤
│ "Add/Create/New/Feature"  → Track A (Feature)
│ "Fix/Bug/Error/Crash"     → Track B (Fix)
│ "Refactor/Clean/Optimize" → Track C (Refactor)
│ 其他简单任务               → Track D (Direct)
└─────────────────────────────────┘
```

---

## Conflict Arbitration Protocol (冲突仲裁协议)

> **多 agent 最常见情况：分身意见不一致** - 必须有明确的仲裁规则。

### 常见冲突场景

```
冲突类型示例：
├── 🧠意 说: "这样设计更优雅"
├── 👃鼻 说: "风险太大，安全隐患"
├── ⚔️身 说: "实现成本太高"
└── 👅舌 说: "这个方案测不了"
```

### 冲突处理流程

```
┌─────────────────────────────────────────────────────────────────┐
│  Step 1: 冲突显式化                                              │
│  ┌────────────────────────────────────────────────────────────┐ │
│  │ 谁        │ 观点                    │ 证据                  │ │
│  │───────────│─────────────────────────│──────────────────────│ │
│  │ 🧠意      │ 使用微服务架构           │ 可扩展性好            │ │
│  │ 👃鼻      │ 单体更安全               │ 减少网络攻击面        │ │
│  │ ⚔️身      │ 单体实现成本低           │ 工时估算: 2天 vs 2周  │ │
│  └────────────────────────────────────────────────────────────┘ │
│                              │                                   │
│                              ▼                                   │
├─────────────────────────────────────────────────────────────────┤
│  Step 2: 本体按优先级裁决                                        │
│                                                                   │
│  裁决三准则 (按优先级排序):                                       │
│                                                                   │
│  1️⃣ 满足 AC 优先                                                │
│     → 哪个方案能满足验收标准？不满足 AC 的方案直接排除             │
│                                                                   │
│  2️⃣ 风险可控优先                                                │
│     → 安全/数据丢失/不可逆 风险必须优先考虑                       │
│     → 宁可牺牲优雅，不可牺牲安全                                  │
│                                                                   │
│  3️⃣ 最小改动优先                                                │
│     → 尤其 Fix 轨道，能小改不大改                                 │
│     → 避免过度工程                                                │
│                              │                                   │
│                              ▼                                   │
├─────────────────────────────────────────────────────────────────┤
│  Step 3: 输出 Decision Log (决策日志)                            │
│                                                                   │
│  ```markdown                                                      │
│  ## Decision Log: {decision_id}                                   │
│                                                                   │
│  **日期**: {date}                                                 │
│  **冲突**: {描述冲突}                                             │
│                                                                   │
│  **各方观点**:                                                    │
│  - 🧠意: {观点} (证据: {evidence})                                │
│  - 👃鼻: {观点} (证据: {evidence})                                │
│  - ⚔️身: {观点} (证据: {evidence})                                │
│                                                                   │
│  **裁决**: {最终决定}                                             │
│  **依据**: {哪条准则}                                             │
│  **影响**: {影响范围}                                             │
│  **锚点**: [D0xx] {简短描述}                                      │
│  ```                                                              │
│                              │                                   │
│                              ▼                                   │
├─────────────────────────────────────────────────────────────────┤
│  Step 4: 锚点化 (下次直接复用)                                    │
│                                                                   │
│  裁决后创建决策锚点:                                              │
│  [D0xx] {决策} - 基于{准则}，选择{方案}而非{备选}                 │
│                                                                   │
│  下次遇到类似冲突，直接引用锚点，不重复讨论                        │
└─────────────────────────────────────────────────────────────────┘
```

### 仲裁规则速查

| 冲突类型 | 裁决准则 | 示例 |
|----------|----------|------|
| 设计优雅 vs 安全风险 | 2️⃣ 风险可控优先 | 选安全方案 |
| 功能完整 vs 交付时间 | 1️⃣ 满足 AC 优先 | AC 未覆盖的功能可延后 |
| 大重构 vs 小修补 | 3️⃣ 最小改动优先 | Fix 轨道选小修补 |
| 性能优化 vs 代码可读 | 1️⃣ 满足 AC 优先 | 若 AC 无性能要求，选可读 |
| 新技术 vs 成熟方案 | 2️⃣ 风险可控优先 | 除非有明确收益，选成熟方案 |

### 禁止的仲裁行为

```
❌ 禁止:
├── 和稀泥（"两边都有道理，你们自己看着办"）
├── 无证据裁决（"我觉得应该..."）
├── 拖延裁决（"下次再说"）
├── 裁决后不记录（下次重复讨论）
└── 推翻已记录的锚点（除非有新的强证据）
```

### Stage 1: 需求获取 (Requirement Gathering)

```
Input: 用户请求
Avatar: 👂 耳分身 (听)

Tasks:
1. 解析显式需求
2. 推导隐式需求
3. 识别边界条件
4. 确认技术约束

Output: requirements.md
```

### Stage 2: 方案设计 (Solution Design)

```
Input: requirements.md
Avatar: 🧠 意分身 (思)

Tasks:
1. 分析现有架构
2. 设计解决方案
3. 技术选型
4. 识别风险

Output: design.md
```

### Stage 3: 代码实现 (Implementation)

```
Input: design.md
Avatar: ⚔️ 斗战胜佛 (行) + 👁️ 眼分身 (观) (parallel)

Tasks:
1. 眼分身: 研究相关代码 (background)
2. 斗战胜佛: 按设计实现代码
3. 本体: 监督进度，回答问题
4. 增量验证

Output: 代码变更
```

### Stage 4: 测试验证 (Testing)

```
Input: 代码变更
Avatar: 👅 舌分身 (言)

Tasks:
1. 编写单元测试
2. 编写集成测试
3. 验证边界条件
4. 检查覆盖率

Output: 测试通过
```

### Stage 5: 代码审查 (Code Review)

```
Input: 代码变更 + 测试
Avatar: 👃 鼻分身 (觉)

Tasks:
1. 检查代码质量
2. 验证设计一致性
3. 识别潜在问题
4. 提出改进建议

Output: review.md
```

## Resume Protocol (继续协议)

| Scenario | Action |
|----------|--------|
| 上次搜索未完成 | `resume: "<agent_id>"` |
| 需要补充之前的发现 | `resume: "<agent_id>"` |
| 完全不同的任务 | 重新开始 |
| 上下文过期 (>30 min) | 重新开始 |
