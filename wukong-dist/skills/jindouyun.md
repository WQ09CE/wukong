# 筋斗云 (Jindouyun) - 并行执行协议

> **一个筋斗十万八千里** - 分身术的精髓在于**同时出击**，而非排队等候。

## Philosophy (哲学)

筋斗云是悟空的腾云驾雾之术。在任务编排中，筋斗云协议让多个分身能够**同时飞行**：
- 独立任务并行执行，效率倍增
- 依赖任务按序串行，避免混乱
- 文件领地互斥，防止冲突
- 资源合理分配，稳定可控

---

## The Parallelization Decision Tree (并行决策树)

```
开始任务分析
     │
     ▼
┌─────────────────────────────────────────┐
│ Q1: 任务可以分解为多个独立子任务吗？        │
└─────────────────────────────────────────┘
     │
     ├── NO → 单分身串行执行
     │
     ▼ YES
┌─────────────────────────────────────────┐
│ Q2: 子任务之间有数据依赖吗？               │
│     (一个的输出是另一个的输入)              │
└─────────────────────────────────────────┘
     │
     ├── YES → 按依赖顺序串行
     │
     ▼ NO
┌─────────────────────────────────────────┐
│ Q3: 子任务会修改同一个文件吗？             │
└─────────────────────────────────────────┘
     │
     ├── YES → 串行执行（避免冲突）或领地分区
     │
     ▼ NO
┌─────────────────────────────────────────┐
│ ✅ 可以并行！召唤多个分身同时执行          │
└─────────────────────────────────────────┘
```

---

## Parallelization Patterns (并行模式)

### Pattern 1: 分身群攻 (Multi-Module Implementation)

**场景**: 实现多个独立模块（无相互依赖）
**加速比**: 理论 Nx（N = 模块数）

```
设计完成后:
     │
     ├──→ [斗战胜佛 A] 实现 module_a.py  ──┐
     ├──→ [斗战胜佛 B] 实现 module_b.py  ──┼──→ 合并验证
     └──→ [斗战胜佛 C] 实现 module_c.py  ──┘

# 召唤方式 (在同一条消息中发送多个 Task)
Task(subagent_type="general-purpose", prompt="实现 module_a", run_in_background=true)
Task(subagent_type="general-purpose", prompt="实现 module_b", run_in_background=true)
Task(subagent_type="general-purpose", prompt="实现 module_c", run_in_background=true)
```

**适用条件**:
- 模块之间无调用依赖
- 每个模块有独立的文件
- 接口契约已事先定义

---

### Pattern 2: 侦察兵 + 主力军 (Scout & Infantry)

**场景**: 实现功能时需要不断查阅参考
**加速比**: 减少等待时间

```
开始实现:
     │
     ├──→ [眼分身] 研究相关 API 和模式 (后台)
     │         │
     │         └──→ 持续提供参考信息
     │
     └──→ [斗战胜佛] 开始实现代码
               │
               └──→ 遇到不确定时，从眼分身获取答案

# 召唤方式
Task(subagent_type="Explore", prompt="研究 X 库的用法和最佳实践", run_in_background=true)
Task(subagent_type="general-purpose", prompt="实现 Y 功能，参考眼分身的发现")
```

**适用条件**:
- 实现时需要大量参考资料
- 探索和实现可同步进行
- 眼分身的发现可实时注入

---

### Pattern 3: TDD 钳形攻势 (Test + Implement Pincer)

**场景**: 接口已明确定义（设计文档/头文件）
**加速比**: ~2x

```
接口定义完成:
     │
     ├──→ [舌分身] 根据接口编写测试 (后台)
     │
     └──→ [斗战胜佛] 实现接口 (后台)
               │
               ▼
          [合并] → 运行测试 → 验证

# 召唤方式
Task(subagent_type="general-purpose", prompt="根据接口定义编写测试", run_in_background=true)
Task(subagent_type="general-purpose", prompt="实现接口", run_in_background=true)
# 等待两者完成后运行测试
```

**适用条件**:
- 接口契约清晰明确
- 测试用例可从接口推导
- 实现和测试相互独立

---

### Pattern 4: 代码 + 配置并行 (Code + Config Parallel)

**场景**: 实现代码的同时准备部署配置
**加速比**: ~1.5x

```
设计完成后:
     │
     ├──→ [斗战胜佛] 实现核心代码
     │
     └──→ [意分身] 准备 Dockerfile / CI 配置 (后台)
               │
               └──→ 容器配置不依赖具体实现细节

# 召唤方式
Task(subagent_type="general-purpose", prompt="实现核心功能代码")
Task(subagent_type="general-purpose", prompt="准备 Dockerfile 和 docker-compose", run_in_background=true)
```

**适用条件**:
- 配置只依赖设计，不依赖实现细节
- 部署结构已确定
- 配置和代码改动文件不重叠

---

### Pattern 5: 蜂群模式 (Swarm - Mass Operations)

**场景**: 批量重构/迁移多个独立文件
**加速比**: ~Nx

```
重构计划确定后:
     │
     ├──→ [斗战胜佛 A] 重构 file_1.py  ──┐
     ├──→ [斗战胜佛 B] 重构 file_2.py  ──┤
     ├──→ [斗战胜佛 C] 重构 file_3.py  ──┼──→ 合并
     └──→ [斗战胜佛 D] 重构 file_4.py  ──┘

# 召唤方式 (限制同时 3-4 个分身)
Task(subagent_type="general-purpose", prompt="重构 file_1", run_in_background=true)
Task(subagent_type="general-purpose", prompt="重构 file_2", run_in_background=true)
Task(subagent_type="general-purpose", prompt="重构 file_3", run_in_background=true)
```

**适用条件**:
- 每个文件独立重构
- 重构规则统一
- 无跨文件依赖变更

---

## Parallelization Rules (并行规则)

### ✅ 可以并行的场景

| 场景 | 模式 | 最大并行数 |
|------|------|-----------|
| 实现多个独立模块 | 分身群攻 | 3-4 |
| 实现 + 探索参考 | 侦察兵+主力军 | 2 |
| 实现 + 写测试 (接口已定) | TDD钳形攻势 | 2 |
| 代码 + 部署配置 | 代码+配置并行 | 2 |
| 批量文件修改 | 蜂群模式 | 3-4 |
| 多文件代码审查 | 审查分身群 | 3-4 |
| 多模块代码探索 | 探索分身群 | 3-4 |

### ❌ 必须串行的场景

| 场景 | 原因 |
|------|------|
| 需求 → 架构 → 实现 | 依赖上游输出 |
| 修改同一文件的多个任务 | 会产生冲突 |
| 测试依赖未完成的代码 | 会失败 |
| 需要用户确认的决策点 | 阻塞等待 |
| A 的输出是 B 的输入 | 数据依赖 |
| 接口变更 + 调用方修改 | 接口需先稳定 |

---

## Parallel Execution Syntax (并行召唤语法)

**关键**: 在**同一条消息**中发送多个 Task 调用

```python
# ✅ 正确: 同一消息中多个 Task (并行执行)
<message>
Task(subagent_type="general-purpose", prompt="任务A", run_in_background=true)
Task(subagent_type="general-purpose", prompt="任务B", run_in_background=true)
Task(subagent_type="general-purpose", prompt="任务C", run_in_background=true)
</message>

# ❌ 错误: 分开发送 (串行执行)
<message>Task(...任务A...)</message>
<message>Task(...任务B...)</message>
<message>Task(...任务C...)</message>
```

### 召唤前自检清单

在发起并行任务前，本体必须自问：

```
□ 这些任务涉及几个独立文件/模块？
  → 如果 >= 2 个独立文件，考虑并行

□ 任务之间有数据依赖吗？
  → 如果 A 的输出是 B 的输入，必须串行

□ 任务会修改同一个文件吗？
  → 如果是，必须串行或领地分区

□ 资源足够吗？
  → 最多同时 3-4 个分身

□ 能在一条消息中发起吗？
  → 并行任务必须同时发起
```

---

## File Territory Protocol (文件领地协议)

> **并行实现时最容易撞车：两个分身改同一个文件** - 用领地协议避免冲突。

### 领地声明规则

```
┌─────────────────────────────────────────────────────────────────┐
│  1️⃣ 实现前声明领地                                              │
│     斗战胜佛开始实现前，必须声明改动领地:                         │
│                                                                   │
│     ```                                                           │
│     ## 领地声明                                                   │
│     分身: 斗战胜佛 A                                              │
│     领地:                                                         │
│     - src/auth/login.py (全文件)                                 │
│     - src/auth/utils.py (函数: validate_token)                   │
│     - tests/test_auth.py (新增)                                  │
│     ```                                                           │
├─────────────────────────────────────────────────────────────────┤
│  2️⃣ 领地互斥                                                    │
│     其他分身不得在同一领地写实现性内容                            │
│     ✅ 允许: 读取、评论、建议                                     │
│     ❌ 禁止: 编辑、写入、修改                                     │
├─────────────────────────────────────────────────────────────────┤
│  3️⃣ 冲突处理                                                    │
│     若必须重叠 (两个分身需要改同一文件):                          │
│     - 由本体重新分区 (拆分成不重叠的部分)                         │
│     - 或串行化 (先完成一个，再开始另一个)                         │
└─────────────────────────────────────────────────────────────────┘
```

### 领地类型

| 类型 | 格式 | 说明 |
|------|------|------|
| 全文件 | `src/module.py` | 独占整个文件 |
| 函数级 | `src/module.py:func_name` | 只改特定函数 |
| 类级 | `src/module.py:ClassName` | 只改特定类 |
| 新增 | `src/new_file.py (新增)` | 创建新文件 |

### 领地冲突检测

```
本体在分发任务前，检查领地冲突:

任务分发:
├── 斗战胜佛 A: src/auth.py, src/utils.py
├── 斗战胜佛 B: src/api.py, src/utils.py  ← ⚠️ 冲突!
│                          ↑
│                    与 A 的 utils.py 重叠
│
└── 冲突解决:
    ├── 方案1: 重新分区
    │   - A: src/auth.py, src/utils.py:validate_*
    │   - B: src/api.py, src/utils.py:format_*
    │
    └── 方案2: 串行化
        - A 先完成 → B 再开始
```

### 领地释放

```
分身完成任务后，自动释放领地:

斗战胜佛 A 完成:
├── 输出实现报告
├── 标记: 领地已释放
└── 其他分身可接管
```

---

## Resource Management (资源管理)

```
并行分身限制:
├── 最大同时运行: 3-4 个分身
├── 后台探索: 不计入限制
└── 超过限制时: 批次执行

示例 (8个独立模块):
├── 第一批: 模块 1, 2, 3, 4 (并行)
├── 等待完成
└── 第二批: 模块 5, 6, 7, 8 (并行)
```

### 资源分配原则

| 任务类型 | 优先级 | 后台? | 备注 |
|----------|--------|-------|------|
| 核心实现 | 高 | No | 占用主要资源 |
| 代码探索 | 中 | Yes | 后台不计限制 |
| 代码审查 | 中 | Yes | 可后台并行 |
| 配置准备 | 低 | Yes | 低优先级后台 |

### 批次执行策略

当任务数超过并行限制时：

```
1. 按优先级排序任务
2. 高优先级任务优先进入第一批
3. 批内任务并行执行
4. 等待当前批次完成
5. 启动下一批次
6. 重复直到全部完成
```

---

## Merge Protocol (合并协议)

并行任务完成后：

```
1. 收集所有分身的输出
   ├── 实现报告
   ├── 变更文件列表
   └── 自检结果

2. 检查是否有冲突
   ├── 文件级冲突: 两个分身改了同一文件
   └── 逻辑冲突: 接口不匹配

3. 如有冲突 → 手动解决
   ├── 回滚冲突改动
   ├── 指定一个分身修复
   └── 重新合并

4. 运行完整验证 (构建 + 测试)
   ├── 编译/语法检查
   ├── 单元测试
   └── 集成测试

5. 确认无误后继续
```

### 合并检查清单

```
□ 所有分身已完成任务
□ 无文件领地冲突
□ 接口契约一致
□ 构建通过
□ 测试通过
□ 无回归问题
```

---

## Anti-Patterns (反模式)

### ❌ 禁止的行为

```
❌ 把多个独立文件修改打包给一个分身
   → 应该每文件一个分身

❌ 串行执行可并行的探索任务
   → 探索类任务应该并行

❌ 不声明领地就开始修改
   → 必须先声明，再实现

❌ 忽略冲突继续合并
   → 必须先解决冲突

❌ 超过资源限制强行并行
   → 应该批次执行
```

### ✅ 正确的做法

```
✅ 分析任务，识别可并行部分
✅ 定义接口契约后再并行实现
✅ 每个分身明确声明领地
✅ 合并前检查冲突
✅ 资源不足时批次执行
```

---

## Quick Reference (速查表)

### 并行决策

| 问题 | 是 | 否 |
|------|----|---|
| 任务可分解？ | 继续判断 | 串行 |
| 有数据依赖？ | 串行 | 继续判断 |
| 改同一文件？ | 串行/分区 | 可并行 |

### 模式选择

| 场景 | 模式 |
|------|------|
| 多模块实现 | 分身群攻 |
| 需要参考 | 侦察兵+主力军 |
| 接口已定 | TDD钳形攻势 |
| 代码+配置 | 代码+配置并行 |
| 批量修改 | 蜂群模式 |

### 资源限制

| 类型 | 限制 |
|------|------|
| 最大并行 | 3-4 |
| 后台任务 | 不计入 |
| 超限处理 | 批次执行 |
