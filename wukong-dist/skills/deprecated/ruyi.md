# Ruyi Jingu Bang Protocol (如意金箍棒协议)

## Philosophy (理念)

> **大可顶天立地，小可藏于耳内。**
> 信息亦如金箍棒，可伸可缩，随需而变。

如意金箍棒是悟空的神兵利器，可随心意变大变小。在上下文管理中，金箍棒协议让信息也能"随意伸缩"：
- 上下文充足时，展开详细信息
- 上下文紧张时，压缩成核心要点
- 关键信息通过"锚点"永不丢失

## The Three Forms (三态)

### 🔸 缩形态 (Compact Form)

**适用场景**:
- 新分身启动，需要快速了解背景
- 上下文使用 > 75%
- 跨会话信息传递

**字数限制**: < 500 字

**格式模板**:
```markdown
## 🔸 缩形态上下文

【任务】{一句话描述目标}

【已决策】
- {决策1}: {选择} (原因: {简要原因})
- {决策2}: {选择}

【约束】
- {必须遵守的规则1}
- {必须遵守的规则2}

【当前进度】
- 已完成: {完成项}
- 进行中: {当前任务}
- 待处理: {下一步}

【锚点引用】
- 见 [D001], [C002], [I003]
```

---

### 🔹 常形态 (Normal Form)

**适用场景**:
- 正常工作过程
- 分身之间的标准信息传递
- 上下文使用 50-75%

**字数限制**: 500 - 2000 字

**格式模板**:
```markdown
## 🔹 常形态上下文

### 任务背景
{2-3 句话描述背景和目标}

### 已完成工作
| 阶段 | 内容 | 产出 |
|------|------|------|
| 需求 | {描述} | requirements.md |
| 设计 | {描述} | design.md |
| 实现 | {描述} | {files} |

### 关键决策
| ID | 决策 | 选择 | 原因 |
|----|------|------|------|
| D001 | {决策描述} | {选择} | {原因} |

### 当前焦点
{详细描述当前正在做的事情，包括：}
- 目标
- 方法
- 进展
- 问题

### 接口约定
```python
# 关键接口签名
{interface definitions}
```

### 注意事项
- {caveat 1}
- {caveat 2}

### 锚点索引
{列出相关锚点 ID}
```

---

### 🔶 巨形态 (Expanded Form)

**适用场景**:
- 需要完整历史上下文
- 调试复杂问题
- 上下文使用 < 50%

**字数限制**: 无限制（完整内容）

**存储位置**: `.wukong/context/session-{id}/expanded.md`

**格式模板**:
```markdown
## 🔶 巨形态上下文

### 完整会话历史
{按时间顺序记录所有重要交互}

### 所有决策及讨论
{包含决策过程、考虑的替代方案}

### 完整代码变更
{所有文件变更的详细记录}

### 问题与解决
{遇到的所有问题及解决过程}

### 用户偏好记录
{从对话中提取的用户偏好}

### 完整锚点列表
{所有锚点的详细定义}
```

---

## 阿赖耶识 (Alaya-vijnana) - 持久化上下文总线

> **阿赖耶识**：第八识，藏识，含藏一切种子。
> 在悟空系统中，阿赖耶识是**持久化上下文总线**，存储所有可复用的决策、约束、业力。
> **核心原则**: 只存"能影响未来决策"的东西，而不是什么都存。

### 写入规则 (Write Rules)

> **写入条件**: 满足以下任一条件才写入阿赖耶识

```
写入门槛 (满足任一即可):
├── 重复 ≥ 2: 类似问题/决策出现两次以上
│   └── 例: 第二次遇到"FFmpeg内存泄漏"问题
├── 影响大: 涉及架构、安全、性能、合规
│   └── 例: 选择数据库、认证方案、部署架构
└── 可复用: 在其他项目/场景中有参考价值
    └── 例: 通用的设计模式、最佳实践
```

**写入前自检**:
```
□ 这个决策/约束会影响未来的决策吗？
□ 下次遇到类似情况，这个信息有参考价值吗？
□ 如果不记录，会导致重复讨论或重复犯错吗？

三个都是 No → 不写入，只记录在会话中
任一是 Yes → 写入阿赖耶识
```

### 沉淀分类 (Distillation Categories)

| 类别 | 前缀 | 说明 | 示例 |
|------|------|------|------|
| **ADR/锚点** | D/C/I | 架构决策记录、约束、接口 | [D001] 使用 Ollama 作为本地 LLM |
| **Patterns** | M | 经过验证的可复用模式 | [M001] Repository 模式访问数据 |
| **Anti-patterns** | P | 已知陷阱和要避免的做法 | [P001] 避免在循环中调用 API |
| **Checklists** | CK | 可复用的检查清单 | [CK001] API 安全检查清单 |
| **Domain Notes** | DN | 领域特定知识和术语 | [DN001] 该系统的认证流程说明 |

### 阿赖耶识架构

```
┌─────────────────────────────────────────────────────────────────┐
│                      阿赖耶识 (Alaya Store)                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                   │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐               │
│  │   种子库     │  │   业力库     │  │   偏好库     │               │
│  │   (Seeds)   │  │   (Karma)   │  │   (Prefs)   │               │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘               │
│         │                │                │                       │
│         └────────────────┼────────────────┘                       │
│                          │                                        │
│                          ▼                                        │
│              ┌─────────────────────┐                              │
│              │    锚点索引          │                              │
│              │  (Anchor Index)     │                              │
│              │  anchors.md         │                              │
│              └─────────────────────┘                              │
│                                                                   │
│  输入: 慧关验证后的 ADR                                            │
│  输出: 跨会话可复用的知识                                          │
│                                                                   │
└─────────────────────────────────────────────────────────────────┘
```

### 种子类型 (Seed Types)

> **种子 (Bija)**：潜在的因，遇缘则生果。锚点即种子。

| 类型 | 前缀 | 业力 | 说明 | 示例 |
|------|------|------|------|------|
| 决策 | D | 正业 | 架构/技术决策 | [D001] 使用 Ollama 而非 OpenAI |
| 约束 | C | 戒律 | 必须遵守的规则 | [C001] 所有输出必须脱敏 |
| 接口 | I | 正业 | 关键接口定义 | [I001] Agent.review() -> ReviewResult |
| 问题 | P | 恶业 | 已知问题/陷阱 | [P001] FFmpeg 在某格式下泄漏内存 |
| 偏好 | U | 习气 | 用户偏好 | [U001] 用户偏好简洁回复 |
| 模式 | M | 正业 | 可复用模式 | [M001] 使用 Repository 模式访问数据 |

### 业力分类 (Karma Classification)

```
业力三分:

┌─────────────────────────────────────────────────────────────────┐
│  正业 (Kusala Karma) - 善业                                      │
│  ├── 可复用的好决策                                               │
│  ├── 经过验证的模式                                               │
│  ├── 稳定的接口定义                                               │
│  └── 处理: 沉淀为锚点，跨会话复用                                  │
├─────────────────────────────────────────────────────────────────┤
│  中业 (Avyakata Karma) - 无记业                                  │
│  ├── 一次性决策                                                   │
│  ├── 上下文相关的选择                                             │
│  ├── 临时性方案                                                   │
│  └── 处理: 记录但不沉淀，会话结束后可丢弃                          │
├─────────────────────────────────────────────────────────────────┤
│  恶业 (Akusala Karma) - 不善业                                   │
│  ├── 技术债                                                       │
│  ├── 已知隐患                                                     │
│  ├── 临时 workaround                                              │
│  └── 处理: 标记为 [P] 问题锚点，待后续处理                         │
└─────────────────────────────────────────────────────────────────┘
```

### 种子成熟 (Seed Maturation)

> **种子遇缘成熟**：当类似场景再次出现，锚点被激活使用。

```
种子生命周期:

1. 播种 (Seeding)
   慧关提取 ADR → 创建锚点 → 存入 anchors.md

2. 休眠 (Dormancy)
   锚点存储在阿赖耶识，等待被引用

3. 成熟 (Maturation)
   新任务匹配到锚点 → 锚点被激活
   → 分身启动时自动加载相关锚点

4. 果报 (Fruition)
   锚点指导决策 → 避免重复讨论
   → 加速任务完成

5. 更新/废弃 (Update/Obsolete)
   内观检测到锚点过期 → 更新或标记废弃
```

### 锚点格式 (ADR 架构决策记录)

> **锚点 = ADR** - 每个锚点都是一条可复用的工程决策记录，包含完整的决策上下文。

**必须字段**（即使缩形态也要保留）:

| 字段 | 必须 | 说明 |
|------|------|------|
| Decision | ✅ | 做了什么决定 |
| Alternatives | ✅ | 考虑过的备选方案 |
| Why | ✅ | 选择的理由 |
| Impact | ✅ | 影响范围（哪些模块/功能受影响） |
| Verification | ✅ | 如何验证这个决策是正确的 |
| Rollback | ✅ | 如果需要回滚，怎么做 |

**完整格式模板**:

```markdown
## [D001] 使用 Ollama 作为本地 LLM

**ID**: D001
**日期**: 2024-01-15
**状态**: ✅ 生效 / ⚠️ 待验证 / ❌ 已废弃

### Decision (决策)
使用 Ollama 作为代码审查的本地 LLM 后端。

### Alternatives (备选方案)
| 方案 | 优点 | 缺点 |
|------|------|------|
| OpenAI API | 能力强 | 成本高、数据出境 |
| Ollama 本地 | 免费、数据本地 | 需要部署维护 |
| Claude API | 能力强 | 合规考虑 |

### Why (理由)
1. 成本: 本地运行零 API 费用
2. 隐私: 代码数据不出本地
3. 合规: 满足企业数据安全要求

### Impact (影响范围)
- `src/llm/`: LLM 接口模块
- `docker-compose.yaml`: 需要添加 Ollama 容器
- 部署流程: 需要 GPU 支持

### Verification (验证方式)
```bash
# 验证 Ollama 正常工作
curl http://localhost:11434/api/generate -d '{"model": "codellama"}'
# 验证审查功能
pytest tests/test_review.py -v
```

### Rollback (回滚方式)
1. 修改 `src/llm/config.py` 切换回 OpenAI
2. 删除 docker-compose 中的 Ollama 服务
3. 设置环境变量 `LLM_BACKEND=openai`
```

**缩形态格式** (压缩时使用):

```markdown
[D001] Ollama 作为本地 LLM
- Why: 成本低、数据本地化、隐私合规
- Impact: src/llm/, docker-compose
- Rollback: 改 LLM_BACKEND=openai
```

### 锚点存储

```
.wukong/context/
└── anchors.md    # 所有锚点的集中存储
```

### 锚点引用

在任何形态中，通过 `[D001]` 格式引用锚点：

```markdown
根据 [D001]，我们使用 Ollama 作为 LLM 后端。
考虑到 [C001] 的脱敏要求，需要在返回前调用 Sanitizer。
```

---

## Form Switching (形态切换)

### 自动切换规则

```
上下文使用监测:
├── < 50%  → 🔶 巨形态 (完整信息)
├── 50-70% → 🔹 常形态 (结构化压缩)
├── 70-85% → 🔸 缩形态 (核心摘要) + 修剪提醒
├── 85-95% → 触发 DCP 动态修剪
└── > 95%  → 触发"存档+重启"协议
```

### 阶梯响应机制

| 阈值 | 状态 | 动作 |
|------|------|------|
| 70% | ⚠️ 黄灯 | 提醒"上下文还有空间"，防止仓促收尾 |
| 85% | 🟠 橙灯 | 自动执行 DCP 修剪策略 |
| 95% | 🔴 红灯 | 强制存档，压缩后继续 |

### 存档+重启协议

当上下文接近满时：

```
1. 自动保存
   ├── 生成 expanded.md (完整历史)
   ├── 生成 normal.md (结构化摘要)
   └── 生成 compact.md (核心要点)

2. 通知用户
   "上下文接近上限，已自动存档。
    你可以：
    - 继续当前会话（我会使用压缩上下文）
    - 开始新会话（说'继续{任务名}'，我会加载存档）"

3. 如果继续
   └── 使用 compact.md 作为起点
       └── 需要详情时 Read normal.md 或 expanded.md
```

### 手动切换

用户可以主动请求切换：

| 用户说 | 动作 |
|--------|------|
| "详细说说" | 切换到巨形态 |
| "简要概括" | 切换到缩形态 |
| "存档一下" | 执行存档协议 |
| "加载上下文" | 读取最近存档 |
| "修剪上下文" | 执行 DCP 修剪 |

---

## Dynamic Context Pruning (动态上下文修剪)

> 借鉴自 [oh-my-opencode](https://github.com/code-yeongyu/oh-my-opencode) 的 DCP 插件设计。
> **核心理念**: 主动移除过时的工具输出，保留关键信息，防止上下文"中毒"。

### DCP 策略矩阵

```
动态上下文修剪 (DCP):
├── 自动策略 (零成本):
│   ├── 🔄 Deduplication  - 去重复工具调用
│   ├── 📝 Supersede      - 覆盖过时的文件读取
│   ├── ❌ Purge Errors   - 清理失败工具输出
│   └── ✂️ Truncation     - 截断冗长输出
│
├── 保护机制:
│   ├── 🛡️ Turn Protection - 轮次保护
│   └── 📌 Anchor Protection - 锚点保护
│
└── AI辅助策略:
    └── 🗑️ Discard - 内观悟空主动标记可删除内容
```

### 自动策略详解

#### 🔄 Deduplication (去重复)

**原理**: 同一文件/资源的多次读取，只保留最新结果。

```
示例:
├── Turn 5: Read("config.py") → 保留
├── Turn 8: Read("config.py") → 最新，保留
├── Turn 3: Read("config.py") → 旧的，修剪 ✂️
└── Turn 5 的结果被 Turn 8 覆盖
```

**配置**:
```yaml
deduplication:
  enabled: true
  scope:
    - Read           # 文件读取
    - Glob           # 文件搜索
    - Grep           # 内容搜索
```

#### 📝 Supersede Writes (覆盖写入)

**原理**: 写入后又被读取的文件，删除写入时的内容（读取结果已包含最新状态）。

```
示例:
├── Turn 3: Write("app.py", content) → 修剪 ✂️
├── Turn 5: Read("app.py") → 保留 (包含最新内容)
└── Write 的内容已过时，Read 的结果更准确
```

#### ❌ Purge Errors (清理错误)

**原理**: 失败的工具调用，在 N 轮后清理其输入内容（保留错误信息）。

```
配置:
purge_errors:
  enabled: true
  turns_before_purge: 4    # 4轮后清理
  keep_error_message: true  # 保留错误信息用于学习
```

#### ✂️ Truncation (输出截断)

**原理**: 搜索类工具的输出动态截断，防止单次搜索吃掉全部上下文。

```
截断规则:
├── Grep 输出: 保留 50% 剩余空间，最大 50k tokens
├── Glob 输出: 最多 200 个文件路径
├── 搜索结果: 保留前 N 个最相关的
└── 长文件: 分块读取而非一次性读取

计算公式:
max_output = min(50000, remaining_context * 0.5)
```

**截断时优先保留**:
1. 匹配度最高的结果
2. 最近修改的文件
3. 与当前任务相关的内容

### 保护机制

#### 🛡️ Turn Protection (轮次保护)

**原理**: 最近 N 轮的内容不被修剪，避免丢失正在进行的工作。

```
配置:
turn_protection:
  protected_turns: 4       # 最近4轮不修剪
  applies_to:
    - tool_outputs         # 工具输出
    - assistant_responses  # 助手回复
```

#### 📌 Anchor Protection (锚点保护)

**原理**: 包含锚点引用的内容永不修剪。

```
规则:
├── 包含 [Dxxx] 的决策内容 → 保护
├── 包含 [Cxxx] 的约束内容 → 保护
├── 包含 [Ixxx] 的接口定义 → 保护
└── 锚点文件 anchors.md → 永不修剪
```

### AI辅助策略

#### 🗑️ Discard (主动丢弃)

**执行者**: 内观悟空

**触发时机**:
- 上下文 > 70% 时的标准/深度内观
- 用户主动请求 "修剪上下文"

**工作流程**:
```
内观悟空扫描上下文:
├── 识别可丢弃内容:
│   ├── 已完成且不再需要的探索结果
│   ├── 已解决问题的调试信息
│   ├── 被否决的方案讨论
│   └── 重复的确认对话
│
├── 生成丢弃建议:
│   | 内容 | 类型 | 丢弃原因 | 安全? |
│   |------|------|----------|-------|
│   | Turn 5 Grep 结果 | 搜索 | 已找到目标 | ✅ |
│   | Turn 8 错误堆栈 | 错误 | 已修复 | ✅ |
│   | Turn 12 方案讨论 | 讨论 | 已决策 | ⚠️ 创建锚点 |
│
└── 执行丢弃 (或等待确认)
```

### DCP 配置文件

存储位置: `.wukong/context/dcp-config.yaml`

```yaml
# DCP 配置
dcp:
  enabled: true

  # 自动策略
  auto_strategies:
    deduplication: true
    supersede_writes: true
    purge_errors: true
    truncation: true

  # 保护机制
  protection:
    turn_protection: 4          # 最近4轮不修剪
    anchor_protection: true     # 锚点内容保护
    protected_patterns:         # 保护的文件模式
      - "*.md"
      - "anchors.md"
      - "requirements.md"
      - "design.md"

  # 截断配置
  truncation:
    grep_max_tokens: 50000
    grep_headroom: 0.5          # 保留50%剩余空间
    glob_max_files: 200
    read_chunk_size: 1000       # 分块读取行数

  # AI辅助
  ai_assisted:
    discard_enabled: true
    require_confirmation: false  # 自动执行或需要确认

  # 错误清理
  error_purge:
    turns_before_purge: 4
    keep_error_message: true
```

### DCP 执行时机

```
DCP 触发点:
├── 上下文 > 85% → 自动执行完整 DCP
├── 每次 Grep/Glob 输出 → 自动截断
├── 内观悟空反思时 → AI辅助丢弃
├── 用户说"修剪" → 手动触发
└── 存档前 → 先 DCP 再存档
```

### DCP 执行报告

```markdown
## DCP 执行报告

**执行时间**: {timestamp}
**触发原因**: 上下文使用 87%

### 修剪统计
| 策略 | 修剪项 | 节约 Tokens |
|------|--------|-------------|
| Deduplication | 3 重复读取 | ~2,500 |
| Supersede | 2 过时写入 | ~1,200 |
| Purge Errors | 1 失败调用 | ~800 |
| Truncation | 2 长输出 | ~5,000 |
| **总计** | **8 项** | **~9,500** |

### 保护的内容
- 锚点 [D001]-[D005]: 保护
- 最近 4 轮: 保护
- requirements.md 读取: 保护

### 修剪后状态
- 上下文使用: 87% → 72%
- 可继续工作
```

### 权衡说明

> ⚠️ **缓存 vs 修剪**: DCP 修改消息内容会导致 prompt 缓存失效。
> 但在大多数情况下，**token 节约 > 缓存损失**，尤其是长会话中。

```
何时修剪更划算:
├── 长会话 (> 20 轮) → 修剪
├── 大量搜索结果 → 截断
├── 反复读取同一文件 → 去重
└── 短会话 (< 10 轮) → 可能不需要
```

---

## Context Directory Structure (上下文目录结构)

```
.wukong/context/
├── anchors.md              # 全局锚点索引
├── dcp-config.yaml         # DCP 配置文件
├── current/                # 当前会话
│   ├── compact.md          # 缩形态
│   ├── normal.md           # 常形态
│   ├── expanded.md         # 巨形态
│   └── dcp-report.md       # 最近 DCP 报告
├── sessions/               # 历史会话存档
│   ├── 2024-01-15-code-review-agent/
│   │   ├── compact.md
│   │   ├── normal.md
│   │   ├── expanded.md
│   │   └── dcp-report.md
│   └── 2024-01-16-ruyi-protocol/
│       └── ...
└── templates/              # 模板
    ├── compact-template.md
    ├── normal-template.md
    ├── anchor-template.md
    └── dcp-config-template.yaml
```

---

## Integration with Avatars (与分身系统集成)

### 召唤分身时的上下文传递

```python
# 标准召唤模式
Task(
    subagent_type="general-purpose",
    prompt=f"""
## 🔸 缩形态上下文
{read_compact_context()}

## 相关锚点
{get_relevant_anchors(task_type)}

## 你的任务
{task_description}

## 注意
如需更多上下文，可 Read(".wukong/context/current/normal.md")
"""
)
```

### 分身返回时的上下文更新

```
分身完成任务后:
├── 提取新决策 → 创建锚点 [Dxxx]
├── 提取新约束 → 创建锚点 [Cxxx]
├── 提取新接口 → 创建锚点 [Ixxx]
├── 更新 compact.md
└── 追加到 expanded.md
```

---

## Best Practices (最佳实践)

### 1. 锚点命名

```
✅ 好的锚点:
[D001] 选择 FastAPI 作为后端框架
[C003] PR 描述不得包含代码内容

❌ 差的锚点:
[D001] 框架决策  (太模糊)
[C003] 规则      (无意义)
```

### 2. 压缩原则

```
压缩时保留:
├── 决策结论 (不是讨论过程)
├── 接口签名 (不是实现细节)
├── 约束规则 (不是背景解释)
├── 当前状态 (不是历史过程)
├── 最近 N 轮的完整内容 (轮次保护)
└── 锚点引用的内容 (锚点保护)

压缩时丢弃 (DCP 自动处理):
├── 探索性讨论
├── 已否决的方案
├── 临时调试信息
├── 重复的确认对话
├── 🔄 重复读取的旧结果 (Deduplication)
├── 📝 被后续读取覆盖的写入 (Supersede)
├── ❌ 4轮前的失败工具输入 (Purge)
└── ✂️ 截断后的冗长输出 (Truncation)
```

### 3. 形态选择

```
分身启动 → 缩形态 (快速启动)
分身遇到问题 → 读取常形态
分身需要调试 → 读取巨形态
分身完成 → 更新所有形态
```

---

## Commands (命令)

| 命令 | 描述 |
|------|------|
| `存档` | 保存当前上下文到 sessions/ |
| `加载 {session-name}` | 加载历史会话 |
| `锚点` | 显示所有锚点 |
| `压缩` | 强制切换到缩形态 |
| `展开` | 强制切换到巨形态 |
| `修剪` | 执行 DCP 动态修剪 |
| `修剪报告` | 显示最近 DCP 执行报告 |

---

## Example: Using Ruyi Protocol (示例)

### 场景：长对话后召唤新分身

```
本体检测: 上下文使用 70%

本体: 生成缩形态上下文...

召唤斗战胜佛:
"""
## 🔸 缩形态上下文

【任务】实现 Code Review Agent 的脱敏模块

【已决策】
- [D001] 使用 Ollama 作为本地 LLM
- [D002] 双层架构：Cloud + Local Container
- [D003] 使用正则 + 规则混合脱敏

【约束】
- [C001] 所有输出必须脱敏
- [C002] Git Token 只在容器内使用

【当前进度】
- 已完成: credentials.py, tools.py
- 进行中: sanitizer.py
- 待处理: agent.py, server.py

【锚点引用】
- 接口: [I001] Sanitizer.sanitize(data) -> Any
- 问题: [P001] 注意递归脱敏嵌套结构

## 你的任务
实现 sanitizer.py，遵循 [I001] 接口定义。

## 注意
如需更多上下文: Read(".wukong/context/current/normal.md")
"""
```

这样，新分身只需 ~300 字就能快速了解背景，需要时再读取更多。
